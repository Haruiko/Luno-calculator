<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Boss spawn timers for Luno - Track elite and world boss spawns">
  <title>Boss Timers - Luno Calculator</title>
  <style>
    :root{
      --bg-dark:#0e1621;
      --panel:#1b2838;
      --panel-2:#172230;
      --text:#e5e9f0;
      --muted:#a3b1c6;
      --accent:#4f8cc9;
      --accent-2:#5fa0e0;
      --success:#3fb950;
      --warning:#f59e0b;
      --danger:#ef4444;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter, "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(1000px 600px at 80% -10%, rgba(79,140,201,.15), transparent 60%),
                  radial-gradient(800px 500px at -10% 120%, rgba(79,140,201,.12), transparent 60%),
                  var(--bg-dark);
      color:var(--text);
      min-height:100vh;
      padding: 24px;
    }

    .container{
      max-width: 1200px;
      margin: 0 auto;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      margin-bottom:24px;
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid rgba(255,255,255,.05);
      border-radius: 16px;
      padding: 20px 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    .topbar h1{
      margin:0;
      font-size:1.8rem;
      color:var(--accent);
      letter-spacing:.2px;
    }
    .sub{
      color:var(--muted);
      font-size:.95rem;
      margin-top: 4px;
    }

    .home-link{
      text-decoration:none;
      color:var(--accent);
      background:rgba(79,140,201,.08);
      padding:12px 16px;
      border-radius:10px;
      border:1px solid rgba(79,140,201,.25);
      transition:.2s ease;
      font-weight:600;
    }
    .home-link:hover{ background:rgba(95,160,224,.18); }

    .boss-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .boss-card{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid rgba(255,255,255,.05);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 8px 25px rgba(0,0,0,.3);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .boss-card:hover{
      transform: translateY(-2px);
      box-shadow: 0 12px 35px rgba(0,0,0,.4);
    }

    .boss-header{
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .boss-name{
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--accent);
      margin: 0;
    }

    .boss-type{
      background: rgba(79,140,201,.15);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .boss-info{
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 16px;
      line-height: 1.4;
    }

    .timer-display{
      text-align: center;
      margin: 16px 0;
    }

    .timer-time{
      font-size: 2rem;
      font-weight: 700;
      color: var(--text);
      font-family: 'Courier New', monospace;
      margin-bottom: 8px;
    }

    .timer-status{
      font-size: 0.9rem;
      padding: 6px 12px;
      border-radius: 20px;
      font-weight: 600;
      display: inline-block;
    }

    .status-spawned{
      background: rgba(63, 185, 80, 0.2);
      color: var(--success);
      border: 1px solid rgba(63, 185, 80, 0.3);
    }

    .status-soon{
      background: rgba(245, 158, 11, 0.2);
      color: var(--warning);
      border: 1px solid rgba(245, 158, 11, 0.3);
    }

    .status-waiting{
      background: rgba(148, 163, 184, 0.2);
      color: var(--muted);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }

    .boss-controls{
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 16px;
    }

    .btn{
      background: rgba(79,140,201,.1);
      border: 1px solid rgba(79,140,201,.35);
      color: var(--text);
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: .2s;
      font-weight: 500;
      font-size: 0.9rem;
    }

    .btn:hover{
      background: rgba(95,160,224,.2);
      border-color: rgba(95,160,224,.5);
    }

    .btn.danger{
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.35);
      color: var(--danger);
    }

    .btn.danger:hover{
      background: rgba(239, 68, 68, 0.2);
    }

    .btn.success{
      background: rgba(34, 197, 94, 0.1);
      border-color: rgba(34, 197, 94, 0.35);
      color: var(--success);
    }

    .btn.success:hover{
      background: rgba(34, 197, 94, 0.2);
    }

    .controls-section{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid rgba(255,255,255,.05);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 8px 25px rgba(0,0,0,.3);
    }

    .controls-title{
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 16px;
    }

    .global-controls{
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .notification-dot{
      width: 8px;
      height: 8px;
      background: var(--success);
      border-radius: 50%;
      display: inline-block;
      margin-left: 8px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    @media (max-width: 768px) {
      body { padding: 16px; }
      .topbar { 
        flex-direction: column; 
        align-items: flex-start; 
        gap: 12px; 
      }
      .boss-grid { 
        grid-template-columns: 1fr;
        gap: 16px;
      }
      .boss-controls { 
        flex-wrap: wrap;
      }
      .global-controls {
        flex-direction: column;
      }
      .timer-time { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <div>
        <h1>Boss Spawn Timers</h1>
        <div class="sub">Track elite and world boss spawn times</div>
      </div>
      <a class="home-link" href="index.html">‚Üê Home</a>
    </div>

    <!-- Current Time Display -->
    <div class="card" style="text-align: center; margin-bottom: 20px;">
      <h2 style="color: var(--accent); margin-bottom: 8px;">üïê Current Time (Philippine Time)</h2>
      <div id="currentTime" style="font-size: 1.5rem; font-weight: 600; font-family: 'Courier New', monospace;"></div>
      <div style="color: var(--muted); font-size: 0.9rem; margin-top: 4px;">UTC+8 (Philippine Standard Time)</div>
    </div>

    <!-- Elite Bosses Section -->
    <div class="card" style="margin-bottom: 20px;">
      <h2 style="color: var(--accent); margin-bottom: 16px;">‚öîÔ∏è Elite Bosses</h2>
      <div class="boss-grid" id="bossGrid">
        <!-- Boss cards will be generated here -->
      </div>
    </div>

    <!-- Mythical Creatures Section -->
    <div class="card" style="margin-bottom: 20px;">
      <h2 style="color: var(--success); margin-bottom: 16px;">üåü Mythical Creatures</h2>
      <div class="boss-grid" id="mythicalGrid">
        <!-- Mythical creature cards will be generated here -->
      </div>
    </div>

    <div class="controls-section">
      <div class="controls-title">Global Controls</div>
      <div class="global-controls">
        <button class="btn success" id="startAllBtn">‚ñ∂Ô∏è Start All Timers</button>
        <button class="btn danger" id="resetAllBtn">üîÑ Reset All Timers</button>
        <button class="btn" id="toggleSoundBtn">üîä Sound: ON</button>
        <button class="btn" id="addBossBtn">‚ûï Add Boss</button>
        <button class="btn" id="editBossBtn">‚úèÔ∏è Edit Bosses</button>
        <button class="btn" id="exportBtn">üì§ Export</button>
        <button class="btn" id="importBtn">üì• Import</button>
      </div>
    </div>
  </div>

  <script>
    class BossTimer {
      constructor() {
        this.bosses = this.loadBosses();
        this.mythicalCreatures = this.loadMythicalCreatures();
        this.soundEnabled = localStorage.getItem('bossTimerSound') !== 'false';
        this.intervals = {};
        this.mythicalIntervals = {};
        this.notifications = [];
        this.currentTime = new Date();
        
        this.initializeUI();
        this.startAllTimers();
        this.startMythicalTracking();
        this.startClock();
        this.requestNotificationPermission();
      }

      loadBosses() {
        const saved = localStorage.getItem('bossTimers');
        if (saved) {
          return JSON.parse(saved);
        }
        
        // Blue Protocol Star Resonance - Actual Boss Data
        return [
          {
            id: 'golden_juggernaut',
            name: 'Golden Juggernaut',
            type: 'Elite Boss',
            location: 'Asteria Plains (Scout Lookout Post)',
            level: 'Lv.10',
            spawnInterval: 60, // Every hour on the hour
            lastKilled: null,
            description: 'Boarrierrier leader at abandoned campsite. Drops valuable materials and coins.'
          },
          {
            id: 'brigand_leader',
            name: 'Brigand Leader',
            type: 'Elite Boss',
            location: 'Minsterhorn City (Western Part)',
            level: 'Lv.35',
            spawnInterval: 60, // Every hour on the hour
            lastKilled: null,
            description: 'Brigand leader at the camp in western Minsterhorn city. Handle with care!'
          },
          {
            id: 'venobzzar_incubator',
            name: 'Venobzzar Incubator',
            type: 'Elite Boss',
            location: 'Asterleeds Underground District',
            level: 'Lv.40',
            spawnInterval: 30, // Every half-hour
            lastKilled: null,
            description: 'Bzzar nest appears in the underground district. Be cautious of the swarm!'
          },
          {
            id: 'muku_chief',
            name: 'Muku Chief',
            type: 'Elite Boss',
            location: 'Southern Kanamia Tribe (Monster Camp)',
            level: 'Lv.45',
            spawnInterval: 60, // Every hour on the hour
            lastKilled: null,
            description: 'Muku leader at Monster Camp in Southern Kanamia Tribe. Handle with care!'
          },
          {
            id: 'iron_fang',
            name: 'Iron Fang',
            type: 'Elite Boss',
            location: 'Windhowl Canyon',
            level: 'Lv.50',
            spawnInterval: 30, // Every half-hour
            lastKilled: null,
            description: 'Boarrier leader appears in Windhowl Canyon. Be cautious of its strength!'
          },
          {
            id: 'storm_goblin_king',
            name: 'Storm Goblin King',
            type: 'Elite Boss',
            location: 'Windhowl Canyon',
            level: 'Lv.55',
            spawnInterval: 60, // Every hour on the hour
            lastKilled: null,
            description: 'Leader of storm goblins in Windhowl Canyon. Be cautious of lightning attacks!'
          },
          {
            id: 'tempest_ogre',
            name: 'Tempest Ogre',
            type: 'Elite Boss',
            location: 'Dark Mist Fortress, Asteria Plains',
            level: 'Lv.60',
            spawnInterval: 30, // Every half-hour
            lastKilled: null,
            description: 'Ogre Boss surrounded by lightning in Dark Mist Fortress. Handle with care!'
          }
        ];
      }

      loadMythicalCreatures() {
        const saved = localStorage.getItem('mythicalCreatures');
        if (saved) {
          return JSON.parse(saved);
        }
        
        // Blue Protocol Mythical Creatures - Daily spawns at specific times (Philippine timezone)
        return [
          {
            id: 'lovely_boarlet',
            name: 'Lovely Boarlet',
            type: 'Mythical Creature',
            location: 'Skyquake Fields',
            level: 'Lv.1',
            spawnTimes: ['18:00', '22:00', '02:00'], // 10:00, 14:00, 18:00 UTC-2 converted to Philippine time (UTC+8)
            lastSeen: null,
            description: 'A magical creature that appears daily at specific times on Skyquake Fields.'
          },
          {
            id: 'breezy_boarlet',
            name: 'Breezy Boarlet',
            type: 'Mythical Creature',
            location: 'Skyquake Fields',
            level: 'Lv.1',
            spawnTimes: ['18:00', '22:00', '02:00'], // Same times as Lovely Boarlet
            lastSeen: null,
            description: 'A magical creature that appears daily at specific times on Skyquake Fields.'
          },
          {
            id: 'silver_nappo',
            name: 'Silver Nappo',
            type: 'Mythical Creature',
            location: 'Random Locations',
            level: 'Lv.1',
            spawnInterval: 120, // Every 2 hours at random locations
            lastSeen: null,
            description: 'Appears every 2 hours at random locations. More likely in areas where monsters gather.'
          }
        ];
      }

      saveMythicalCreatures() {
        localStorage.setItem('mythicalCreatures', JSON.stringify(this.mythicalCreatures));
      }

      saveBosses() {
        localStorage.setItem('bossTimers', JSON.stringify(this.bosses));
      }

      initializeUI() {
        this.renderBosses();
        this.renderMythicalCreatures();
        this.setupEventListeners();
        this.updateSoundButton();
      }

      renderBosses() {
        const grid = document.getElementById('bossGrid');
        grid.innerHTML = '';

        this.bosses.forEach(boss => {
          const card = this.createBossCard(boss);
          grid.appendChild(card);
        });
      }

      createBossCard(boss) {
        const card = document.createElement('div');
        card.className = 'boss-card';
        card.innerHTML = `
          <div class="boss-header">
            <h3 class="boss-name">${boss.name} ${boss.level || ''}</h3>
            <span class="boss-type">${boss.type}</span>
          </div>
          <div class="boss-info">
            üìç ${boss.location}<br>
            ‚è±Ô∏è Respawn: ${this.formatDuration(boss.spawnInterval * 60)}<br>
            ${boss.description}
          </div>
          <div class="timer-display">
            <div class="timer-time" id="timer-${boss.id}">--:--:--</div>
            <div class="timer-status" id="status-${boss.id}">Unknown</div>
          </div>
          <div class="boss-controls">
            <button class="btn success" onclick="bossTimer.markKilled('${boss.id}')">‚öîÔ∏è Killed</button>
            <button class="btn" onclick="bossTimer.startTimer('${boss.id}')">‚ñ∂Ô∏è Start</button>
            <button class="btn danger" onclick="bossTimer.resetTimer('${boss.id}')">üîÑ Reset</button>
            <button class="btn" onclick="bossTimer.editBoss('${boss.id}')" style="font-size: 0.8rem;">‚úèÔ∏è</button>
          </div>
        `;
        return card;
      }

      startTimer(bossId) {
        const boss = this.bosses.find(b => b.id === bossId);
        if (!boss) return;

        if (!boss.lastKilled) {
          boss.lastKilled = Date.now();
          this.saveBosses();
        }

        if (this.intervals[bossId]) {
          clearInterval(this.intervals[bossId]);
        }

        this.intervals[bossId] = setInterval(() => {
          this.updateTimer(bossId);
        }, 1000);

        this.updateTimer(bossId);
      }

      updateTimer(bossId) {
        const boss = this.bosses.find(b => b.id === bossId);
        if (!boss || !boss.lastKilled) return;

        const now = Date.now();
        const spawnTime = boss.lastKilled + (boss.spawnInterval * 60 * 1000);
        const timeLeft = spawnTime - now;

        const timerElement = document.getElementById(`timer-${bossId}`);
        const statusElement = document.getElementById(`status-${bossId}`);

        if (timeLeft <= 0) {
          // Boss has spawned
          timerElement.textContent = 'SPAWNED!';
          statusElement.textContent = 'Available';
          statusElement.className = 'timer-status status-spawned';
          
          this.showNotification(boss.name, `${boss.name} has spawned at ${boss.location}!`);
          
          // Stop the timer
          clearInterval(this.intervals[bossId]);
          delete this.intervals[bossId];
        } else {
          // Still waiting
          const hours = Math.floor(timeLeft / (1000 * 60 * 60));
          const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
          const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

          timerElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

          if (timeLeft <= 5 * 60 * 1000) { // 5 minutes warning
            statusElement.textContent = 'Spawning Soon!';
            statusElement.className = 'timer-status status-soon';
          } else {
            statusElement.textContent = 'Waiting...';
            statusElement.className = 'timer-status status-waiting';
          }
        }
      }

      markKilled(bossId) {
        const boss = this.bosses.find(b => b.id === bossId);
        if (!boss) return;

        boss.lastKilled = Date.now();
        this.saveBosses();
        this.startTimer(bossId);
      }

      resetTimer(bossId) {
        const boss = this.bosses.find(b => b.id === bossId);
        if (!boss) return;

        boss.lastKilled = null;
        this.saveBosses();

        if (this.intervals[bossId]) {
          clearInterval(this.intervals[bossId]);
          delete this.intervals[bossId];
        }

        const timerElement = document.getElementById(`timer-${bossId}`);
        const statusElement = document.getElementById(`status-${bossId}`);
        
        timerElement.textContent = '--:--:--';
        statusElement.textContent = 'Not Started';
        statusElement.className = 'timer-status status-waiting';
      }

      startAllTimers() {
        this.bosses.forEach(boss => {
          if (boss.lastKilled) {
            this.startTimer(boss.id);
          }
        });
      }

      resetAllTimers() {
        if (confirm('Are you sure you want to reset all boss timers?')) {
          this.bosses.forEach(boss => {
            this.resetTimer(boss.id);
          });
        }
      }

      toggleSound() {
        this.soundEnabled = !this.soundEnabled;
        localStorage.setItem('bossTimerSound', this.soundEnabled.toString());
        this.updateSoundButton();
      }

      updateSoundButton() {
        const btn = document.getElementById('toggleSoundBtn');
        btn.textContent = this.soundEnabled ? 'üîä Sound: ON' : 'üîá Sound: OFF';
      }

      async requestNotificationPermission() {
        if ('Notification' in window && Notification.permission === 'default') {
          await Notification.requestPermission();
        }
      }

      showNotification(title, message) {
        // Browser notification
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(title, {
            body: message,
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">‚öîÔ∏è</text></svg>'
          });
        }

        // Sound notification
        if (this.soundEnabled) {
          this.playNotificationSound();
        }
      }

      playNotificationSound() {
        // Create a simple notification sound using Web Audio API
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);

          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.3);
        } catch (e) {
          console.log('Could not play notification sound:', e);
        }
      }

      formatDuration(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        
        if (hours > 0) {
          return `${hours}h ${minutes}m`;
        } else {
          return `${minutes}m`;
        }
      }

      setupEventListeners() {
        document.getElementById('startAllBtn').addEventListener('click', () => {
          this.bosses.forEach(boss => {
            if (!boss.lastKilled) {
              boss.lastKilled = Date.now();
            }
          });
          this.saveBosses();
          this.startAllTimers();
        });

        document.getElementById('resetAllBtn').addEventListener('click', () => {
          this.resetAllTimers();
        });

        document.getElementById('toggleSoundBtn').addEventListener('click', () => {
          this.toggleSound();
        });

        document.getElementById('addBossBtn').addEventListener('click', () => {
          this.addCustomBoss();
        });

        document.getElementById('editBossBtn').addEventListener('click', () => {
          this.showEditMode();
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
          this.exportBossData();
        });

        document.getElementById('importBtn').addEventListener('click', () => {
          this.importBossData();
        });
      }

      addCustomBoss() {
        const name = prompt('Enter boss name:');
        if (!name) return;

        const location = prompt('Enter boss location:') || 'Unknown';
        const spawnMinutes = parseInt(prompt('Enter spawn interval in minutes:')) || 120;
        const type = prompt('Enter boss type (Elite Boss/World Boss):') || 'Elite Boss';
        const description = prompt('Enter boss description:') || 'Custom boss';

        const boss = {
          id: `custom_${Date.now()}`,
          name,
          type,
          location,
          spawnInterval: spawnMinutes,
          lastKilled: null,
          description
        };

        this.bosses.push(boss);
        this.saveBosses();
        this.renderBosses();
      }

      editBoss(bossId) {
        const boss = this.bosses.find(b => b.id === bossId);
        if (!boss) return;

        const name = prompt('Boss name:', boss.name);
        if (name === null) return;

        const location = prompt('Boss location:', boss.location);
        if (location === null) return;

        const spawnMinutes = parseInt(prompt('Spawn interval (minutes):', boss.spawnInterval));
        if (isNaN(spawnMinutes)) return;

        const type = prompt('Boss type:', boss.type);
        if (type === null) return;

        const description = prompt('Boss description:', boss.description);
        if (description === null) return;

        boss.name = name;
        boss.location = location;
        boss.spawnInterval = spawnMinutes;
        boss.type = type;
        boss.description = description;

        this.saveBosses();
        this.renderBosses();
        
        // Restart timer if it was running
        if (boss.lastKilled) {
          this.startTimer(bossId);
        }
      }

      showEditMode() {
        alert('üí° TIP: Click the ‚úèÔ∏è button on any boss card to edit it, or use the Import button to load Blue Protocol boss data from a JSON file.');
      }

      exportBossData() {
        const data = {
          version: '1.0',
          timestamp: new Date().toISOString(),
          game: 'Blue Protocol Star Resonance',
          bosses: this.bosses
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `blue-protocol-bosses-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      importBossData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              
              if (!data.bosses || !Array.isArray(data.bosses)) {
                alert('Invalid boss data format. Please check your JSON file.');
                return;
              }
              
              if (confirm(`Import ${data.bosses.length} bosses? This will replace your current boss list.`)) {
                // Reset all existing timers
                Object.keys(this.intervals).forEach(id => {
                  clearInterval(this.intervals[id]);
                });
                this.intervals = {};
                
                // Import new bosses
                this.bosses = data.bosses.map(boss => ({
                  ...boss,
                  id: boss.id || `imported_${Date.now()}_${Math.random()}`,
                  lastKilled: null // Reset kill times
                }));
                
                this.saveBosses();
                this.renderBosses();
                
                alert(`Successfully imported ${this.bosses.length} bosses!`);
              }
            } catch (err) {
              alert('Error parsing JSON file: ' + err.message);
            }
          };
          reader.readAsText(file);
        });
        
        input.click();
      }

      renderMythicalCreatures() {
        const grid = document.getElementById('mythicalGrid');
        grid.innerHTML = '';

        this.mythicalCreatures.forEach(creature => {
          const card = this.createMythicalCard(creature);
          grid.appendChild(card);
        });
      }

      createMythicalCard(creature) {
        const card = document.createElement('div');
        card.className = 'boss-card';
        
        let scheduleInfo = '';
        if (creature.spawnTimes) {
          scheduleInfo = `üïê Daily at: ${creature.spawnTimes.join(', ')} (Philippine Time)`;
        } else if (creature.spawnInterval) {
          scheduleInfo = `‚è±Ô∏è Every: ${this.formatDuration(creature.spawnInterval * 60)}`;
        }

        card.innerHTML = `
          <div class="boss-header">
            <h3 class="boss-name">${creature.name} ${creature.level || ''}</h3>
            <span class="boss-type" style="background: rgba(34, 197, 94, 0.15); color: var(--success);">${creature.type}</span>
          </div>
          <div class="boss-info">
            üìç ${creature.location}<br>
            ${scheduleInfo}<br>
            ${creature.description}
          </div>
          <div class="timer-display">
            <div class="timer-time" id="mythical-timer-${creature.id}">--:--:--</div>
            <div class="timer-status" id="mythical-status-${creature.id}">Checking...</div>
          </div>
          <div class="boss-controls">
            <button class="btn success" onclick="bossTimer.markMythicalSeen('${creature.id}')">üëÅÔ∏è Seen</button>
            <button class="btn" onclick="bossTimer.resetMythical('${creature.id}')">üîÑ Reset</button>
          </div>
        `;
        return card;
      }

      startMythicalTracking() {
        this.mythicalCreatures.forEach(creature => {
          this.updateMythicalTimer(creature.id);
          this.mythicalIntervals[creature.id] = setInterval(() => {
            this.updateMythicalTimer(creature.id);
          }, 1000);
        });
      }

      updateMythicalTimer(creatureId) {
        const creature = this.mythicalCreatures.find(c => c.id === creatureId);
        if (!creature) return;

        const now = new Date();
        const philippineTime = new Date(now.getTime() + (8 * 60 * 60 * 1000)); // Convert to Philippine time
        
        const timerElement = document.getElementById(`mythical-timer-${creatureId}`);
        const statusElement = document.getElementById(`mythical-status-${creatureId}`);

        if (creature.spawnTimes) {
          // Daily spawns at specific times
          const nextSpawn = this.getNextSpawnTime(creature.spawnTimes, philippineTime);
          const timeLeft = nextSpawn - philippineTime;

          if (timeLeft <= 0) {
            timerElement.textContent = 'SPAWNING NOW!';
            statusElement.textContent = 'Available';
            statusElement.className = 'timer-status status-spawned';
            
            if (Math.abs(timeLeft) < 60000) { // Within 1 minute of spawn
              this.showNotification(creature.name, `${creature.name} is spawning now at ${creature.location}!`);
            }
          } else {
            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

            timerElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            if (timeLeft <= 5 * 60 * 1000) { // 5 minutes warning
              statusElement.textContent = 'Spawning Soon!';
              statusElement.className = 'timer-status status-soon';
            } else {
              statusElement.textContent = 'Waiting...';
              statusElement.className = 'timer-status status-waiting';
            }
          }
        } else if (creature.spawnInterval) {
          // Regular interval spawns (like Silver Nappo)
          if (creature.lastSeen) {
            const spawnTime = new Date(creature.lastSeen).getTime() + (creature.spawnInterval * 60 * 1000);
            const timeLeft = spawnTime - now.getTime();

            if (timeLeft <= 0) {
              timerElement.textContent = 'AVAILABLE!';
              statusElement.textContent = 'Ready to Spawn';
              statusElement.className = 'timer-status status-spawned';
            } else {
              const hours = Math.floor(timeLeft / (1000 * 60 * 60));
              const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
              const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

              timerElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
              statusElement.textContent = 'Waiting...';
              statusElement.className = 'timer-status status-waiting';
            }
          } else {
            timerElement.textContent = 'AVAILABLE!';
            statusElement.textContent = 'Ready to Spawn';
            statusElement.className = 'timer-status status-spawned';
          }
        }
      }

      getNextSpawnTime(spawnTimes, currentTime) {
        const currentHour = currentTime.getHours();
        const currentMinute = currentTime.getMinutes();
        const currentSecond = currentTime.getSeconds();
        
        for (let timeStr of spawnTimes) {
          const [hour, minute] = timeStr.split(':').map(Number);
          const spawnTime = new Date(currentTime);
          spawnTime.setHours(hour, minute, 0, 0);
          
          // If spawn time hasn't passed today
          if (hour > currentHour || (hour === currentHour && minute > currentMinute) || 
              (hour === currentHour && minute === currentMinute && currentSecond < 30)) {
            return spawnTime;
          }
        }
        
        // All spawn times have passed today, get first spawn time tomorrow
        const [hour, minute] = spawnTimes[0].split(':').map(Number);
        const nextSpawn = new Date(currentTime);
        nextSpawn.setDate(nextSpawn.getDate() + 1);
        nextSpawn.setHours(hour, minute, 0, 0);
        return nextSpawn;
      }

      markMythicalSeen(creatureId) {
        const creature = this.mythicalCreatures.find(c => c.id === creatureId);
        if (!creature) return;

        creature.lastSeen = Date.now();
        this.saveMythicalCreatures();
        this.updateMythicalTimer(creatureId);
      }

      resetMythical(creatureId) {
        const creature = this.mythicalCreatures.find(c => c.id === creatureId);
        if (!creature) return;

        creature.lastSeen = null;
        this.saveMythicalCreatures();
        this.updateMythicalTimer(creatureId);
      }

      startClock() {
        this.updateClock();
        setInterval(() => {
          this.updateClock();
        }, 1000);
      }

      updateClock() {
        const now = new Date();
        const philippineTime = new Date(now.getTime() + (8 * 60 * 60 * 1000));
        
        const timeString = philippineTime.toLocaleTimeString('en-PH', {
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
        
        const dateString = philippineTime.toLocaleDateString('en-PH', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });

        document.getElementById('currentTime').innerHTML = `
          <div style="font-size: 2rem; color: var(--accent);">${timeString}</div>
          <div style="font-size: 1rem; color: var(--muted); margin-top: 4px;">${dateString}</div>
        `;
      }
    }

    // Initialize the boss timer system
    let bossTimer;
    document.addEventListener('DOMContentLoaded', () => {
      bossTimer = new BossTimer();
    });
  </script>
</body>
</html>